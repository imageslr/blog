---
layout: post
title: 📔【操作系统】写时复制 Copy-on-write
date: 2020/9/6 15:00
---


## Copy-on-write 简介
写时复制（Copy-on-write，COW），有时也称为隐式共享（implicit sharing）COW **将复制操作推迟到第一次写入时**进行：在创建一个新副本时，不会立即复制资源，而是共享原始副本的资源；当修改时再执行复制操作。通过这种方式共享资源，可以显著减少创建副本时的开销，同时，资源修改操作会增加少量开销。

## 为什么需要 Copy-on-write
通过 `fork()` 可以创建一个子进程。在这个过程中，操作系统需要将父进程的数据段、堆栈段全部拷贝到子进程中（代码段共享）。这个操作是非常耗时的。

但是，按照以往的使用经验，子进程一般会直接通过 `exec()` 来执行一个新的程序，完全替换掉当前进程的地址空间。因此，在 `fork()` 期间复制父进程的内存空间的操作就被浪费掉了，因此引入了写时复制技术。

## Copy-on-write 实现原理
`fork()` 之后，内核会把父进程的所有内存页都标记为**只读**。一旦其中一个进程尝试写入某个内存页，就会触发一个页面异常（Page Fault）。此时会陷入内核，内核将拦截写入并尝试分配一个新的物理页面，该页面在父子进程中各自独立。
> Page Fault 的处理：[陷阱、中断、异常、信号]({% post_url 2020-07-10-trap-interrupt-exception%})

内核会保留每个内存页面的引用数。每次复制某个页面后，该页面的引用数减少一；如果该页面只有一个引用，就可以跳过分配，直接修改。

这种分配过程对于进程来说是透明的，能够确保一个进程的内存更改在另一进程中不可见。

## 优缺点
优点：减少不必要的资源分配，减少开销。

缺点：如果在子进程存在期间发生了大量写操作，那么会频繁地产生页面错误，不断陷入内核，复制页面。这反而会降低效率。

## 实际应用
Redis 的持久化机制中，如果采用 `bgsave` 或者 `bgrewriteaof` 命令，那么会 fork 一个子进程来将数据存到磁盘中。Redis 的读取操作多，因此这种情况下使用 COW 可以减少 `fork()` 操作的阻塞时间。

写时复制的思想在很多语言中也有应用，相比于传统的深层复制，能带来很大性能提升。比如 C++ 98 标准下的 `std::string` 就采用了写时复制的实现：
```c++
std::string x("Hello");
std::string y = x;  // x、y 共享相同的 buffer
y += ", World!";    // 写时复制，此时 y 使用一个新的 buffer
                    // x 依然使用旧的 buffer
```

Golang、PHP 中的 string、array 也是写时复制。在修改这些类型时，如果其引用计数非零，则会复制一个副本。因此我们在 golang、php 中可以将字符串、数组*当作*值类型（values type）进行传递，即不会有传值复制的开销，也能保证其 immutable 的特性。

---

参考资料：
* [Copy-on-write - Wikipedia](https://en.wikipedia.org/wiki/Copy-on-write#)
* [Copy On Write 机制 - Java3y](https://juejin.im/post/5bd96bcaf265da396b72f855)