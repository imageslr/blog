---
layout: post
title: ğŸ“ã€LeetCodeã€‘212 å•è¯æœç´¢ II
date: 2020/2/1 14:00
permalink: 2020/02/01/leetcode-212.html
---

è¿™é“é¢˜æ˜¯ [LeetCode 212 é¢˜](https://leetcode-cn.com/problems/word-search-ii/)ï¼Œæ˜¯ [79 é¢˜](https://leetcode-cn.com/problems/word-search/)çš„å‡çº§ç‰ˆã€‚

ç»™å®šä¸€ä¸ªäºŒç»´ç½‘æ ¼å’ŒåŒ…å«**å¤šä¸ªå•è¯**çš„å­—å…¸ï¼Œæ‰¾å‡ºæ‰€æœ‰åŒæ—¶åœ¨äºŒç»´ç½‘æ ¼å’Œå­—å…¸ä¸­å‡ºç°çš„å•è¯ã€‚

## è§£æ³•ä¸€ï¼šå›æº¯
ç›´æ¥ä½¿ç”¨ 79 é¢˜çš„ä»£ç ï¼Œä¾æ¬¡æŸ¥æ‰¾æ¯ä¸ªå•è¯æ˜¯å¦åœ¨ `board` ä¸­æœ‰ä¸€æ¡å¯¹åº”çš„è·¯å¾„ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$(nÃ—4^L)$ï¼Œ$n$ ä¸ºå•è¯ä¸ªæ•°ï¼Œ$L$ ä¸ºå•è¯çš„æœ€å¤§é•¿åº¦
* æœç´¢æ¯ä¸ªå•è¯çš„æ—¶é—´å¤æ‚åº¦ç›¸å½“äºæœç´¢æ ‘çš„èŠ‚ç‚¹æ•°ã€‚æœç´¢æœ€å¤§æ·±åº¦ä¸º $L$ï¼Œ$L$ ä¸ºå½“å‰å•è¯çš„é•¿åº¦ï¼›æ¯æ¬¡æœç´¢å¯èƒ½å‘ 4 ä¸ªæ–¹å‘åˆ†å‰ã€‚æ•…æœç´¢æ ‘æ˜¯ä¸€é¢—æœ€å¤§æ·±åº¦ä¸º $L$ çš„ 4 å‰æ ‘ï¼Œå…¶èŠ‚ç‚¹æ€»æ•°ä¸º $O(4^L)$
* å¯¹äºæ¯ä¸ªå•è¯ï¼Œéœ€è¦é‡æ–°æ„é€ æœç´¢æ ‘

ç”¨æ—¶ 252msã€‚

```go
var res []string

func findWords(board [][]byte, words []string) []string {
	if len(words) == 0 || len(board) == 0 {
		return nil
	}
	res = nil
	for _, w := range words {
		if exist(board, w) {
			res = append(res, w)
		}
	}
	return res
}

func exist(board [][]byte, word string) bool {
	if len(word) == 0 || len(board) == 0 {
		return false
	}
	for i := 0; i < len(board); i++ { // ä»æ¯ä¸ªä½ç½®å¼€å§‹æ‰¾
		for j := 0; j < len(board[0]); j++ {
			if dfs(board, i, j, word) {
				return true
			}
		}
	}
	return false
}

// rowã€col è¡¨ç¤ºå½“å‰æœç´¢çš„èµ·å§‹ä½ç½®ï¼Œboard[i][j]=='$' è¡¨ç¤º board[i][j] å·²ç»è¢«æœç´¢
func dfs(board [][]byte, row, col int, word string) bool {
	if board[row][col] != word[0] {
		return false
	}
	if len(word) == 1 {
		return true
	}
	board[row][col] = '$'
	found := false
	if row > 0 && board[row-1][col] != '$' {
		found = found || dfs(board, row-1, col, word[1:])
	}
	if col < len(board[0])-1 && board[row][col+1] != '$' {
		found = found || dfs(board, row, col+1, word[1:])
	}
	if row < len(board)-1 && board[row+1][col] != '$' {
		found = found || dfs(board, row+1, col, word[1:])
	}
	if col > 0 && board[row][col-1] != '$' {
		found = found || dfs(board, row, col-1, word[1:])
	}
	board[row][col] = word[0]
	return found
}
```

## è§£æ³•äºŒï¼šå›æº¯ + å‰ç¼€æ ‘
è§£æ³•ä¸€ä¸­ï¼Œ**æ¯ä¸ªå•è¯æ˜¯ç‹¬ç«‹æŸ¥æ‰¾**ï¼Œå¯¹äºæœ‰ç›¸åŒå‰ç¼€çš„å¤šä¸ªå•è¯ï¼Œè¿™äº›å‰ç¼€çš„è·¯å¾„ä¼šè¢«é‡å¤çš„æœç´¢ã€‚æ¯”å¦‚ `food` å’Œ `foot`ï¼ŒæŸ¥æ‰¾ `food` çš„æ—¶å€™å¯èƒ½å°±å·²ç»æœåˆ° `foo` çš„è·¯å¾„äº†ï¼Œ`foot` å¯ä»¥ç›´æ¥ä» `foo` çš„è·¯å¾„ç»§ç»­å¾€ä¸‹æœç´¢ã€‚

å¯ä»¥ä½¿ç”¨å‰ç¼€æ ‘ä¼˜åŒ–ï¼Œå‰ç¼€æ ‘å¯ä»¥ç›´æ¥ä½¿ç”¨ [208 é¢˜](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)çš„ä»£ç ã€‚è¿™ç›¸å½“äº**æ‰¹é‡åœ°æŸ¥æ‰¾å¤šä¸ªå•è¯**ï¼Œç›¸åŒçš„å‰ç¼€åªä¼šæŸ¥æ‰¾ä¸€æ¬¡ï¼ŒèŠ‚çœäº†æ—¶é—´ã€‚

å‰ç¼€æ ‘çš„æ€§è´¨æ˜¯ï¼šè‹¥å‰ç¼€æ ‘çš„æŸä¸ªèŠ‚ç‚¹ `isLast==true`ï¼Œåˆ™å‰ç¼€æ ‘æ ¹èŠ‚ç‚¹åˆ°è¿™ä¸ªèŠ‚ç‚¹çš„è·¯å¾„æ„æˆäº†ä¸€ä¸ªå•è¯ã€‚é‚£ä¹ˆè§£æ³•äºŒçš„æ€è·¯å¯ä»¥æè¿°ä¸ºï¼šâ€œ**ä¾æ¬¡æŸ¥æ‰¾å‰ç¼€æ ‘ä¸­ä»æ ¹èŠ‚ç‚¹åˆ° `isLast==true` çš„èŠ‚ç‚¹çš„æ¯æ¡è·¯å¾„ï¼Œæ˜¯å¦åœ¨ `board` ä¸­æœ‰ä¸€æ¡åŒæ ·çš„è·¯å¾„**â€ã€‚

å‡è®¾æœ‰è¿™æ ·ä¸€ä¸ªé—®é¢˜ï¼šåˆ†åˆ«ä»äºŒå‰æ ‘ A å’Œ B çš„æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œæœç´¢ä¸¤ä¸ªæ ‘æ˜¯å¦æœ‰ç›¸åŒçš„è·¯å¾„ã€‚é‚£ä¹ˆè‚¯å®šæ˜¯ä¸¤é¢—æ ‘åŒæ­¥æœç´¢ï¼šå¦‚æœ `rootA.val == rootB.val`ï¼Œåˆ™æ ‘ A è¿›å…¥å·¦å­æ ‘ï¼Œæ ‘ B ä¹Ÿè¿›å…¥å·¦å­æ ‘ï¼›å¦åˆ™ï¼Œå›é€€åˆ°ä¸Šä¸€å±‚ï¼Œæ¢ä¸€æ£µå­æ ‘ç»§ç»­æœç´¢ã€‚

åŒç†ï¼Œå¦‚æœæˆ‘ä»¬å°†é€’å½’æœç´¢ `board` çš„è¿‡ç¨‹æƒ³è±¡æˆä¸€æ£µæœç´¢æ ‘ï¼Œé‚£ä¹ˆå‰ç¼€æ ‘å’Œ `board` çš„æœç´¢æ ‘ä¹Ÿå¯ä»¥**åŒæ­¥åœ°æ›´æ–°**ï¼šè®¾å‰ç¼€æ ‘çš„å½“å‰èŠ‚ç‚¹ä¸º Aï¼Œæœç´¢æ ‘çš„å½“å‰èŠ‚ç‚¹ä¸º Bï¼Œåˆ™å¦‚æœ A æŸä¸ªå­èŠ‚ç‚¹çš„å€¼ç­‰äº B çš„å€¼ï¼Œé‚£ä¹ˆä»¤ A ä¸ºè¯¥å­èŠ‚ç‚¹ï¼ŒB è¿›å…¥ä¸‹ä¸€å±‚å¼€å§‹æœç´¢ã€‚è¿™é‡Œå¯ä»¥çœ‹ä»£ç ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$(4^L)$ï¼Œ$L$ ä¸ºå•è¯çš„æœ€å¤§é•¿åº¦ã€‚å¯ä»¥è¿™æ ·ç†è§£ï¼šæœ€å·®æƒ…å†µä¸‹ï¼Œæ¯ä¸ªå•è¯éƒ½æ²¡æœ‰ç›¸åŒçš„å‰ç¼€ï¼Œæ­¤æ—¶åˆ©ç”¨å‰ç¼€æ ‘æŸ¥æ‰¾ä¹Ÿç­‰åŒäºä¾æ¬¡æŸ¥æ‰¾æ¯ä¸ªå•è¯ï¼Œè¿™ç§æƒ…å†µä¸‹æ—¶é—´å¤æ‚åº¦åŒè§£æ³•ä¸€ $(nÃ—4^L)$ï¼›è€Œæœ€ä¼˜æƒ…å†µä¸‹ï¼Œæ¯ä¸ªå•è¯éƒ½ç›¸åŒï¼Œè¿™æ—¶åˆ©ç”¨å‰ç¼€æ ‘æŸ¥æ‰¾ç›¸å½“äºåªæŸ¥æ‰¾ä¸€ä¸ªå•è¯ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $(4^L)$ã€‚æ•…å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º $(4^L)$ã€‚

ç”¨æ—¶ 40 msï¼Œæ—¶é—´æ›´çŸ­ã€‚

```go
func findWords(board [][]byte, words []string) []string {
	if len(words) == 0 || len(board) == 0 {
		return nil
	}
	resMap := map[string]int{}
	trie := NewTrie()
	for _, w := range words {
		trie.Insert(w)
	}
	for i := 0; i < len(board); i++ { // ä»æ¯ä¸ªä½ç½®å¼€å§‹æ‰¾
		for j := 0; j < len(board[0]); j++ {
			dfs(trie, board, i, j, "", resMap)
		}
	}
	res := []string{}
	for key := range resMap {
		res = append(res, key)
	}
	return res
}

// åœ¨ä»¥ root ä¸ºæ ¹èŠ‚ç‚¹çš„å‰ç¼€æ ‘ä¸­ï¼Œæœç´¢ board æ˜¯å¦æœ‰åŒ¹é…çš„å‰ç¼€
// root æœ¬èº«ä¸åŒ…å«å­—ç¬¦ï¼Œå…¶å­èŠ‚ç‚¹æ‰åŒ…å«å­—ç¬¦
// rowã€col è¡¨ç¤ºå½“å‰æœç´¢çš„èµ·å§‹ä½ç½®ï¼Œboard[i][j]=='$' è¡¨ç¤º board[i][j] å·²ç»è¢«æœç´¢
func dfs(root *Trie, board [][]byte, row, col int, prefix string, resMap map[string]int) {
	for i, node := range root.children {
		if node != nil && board[row][col] == byte(i)+'a' { // å¦‚æœæŸä¸ªå­èŠ‚ç‚¹å’Œ board èµ·å§‹ç‚¹åŒ¹é…
			nextPrefix := prefix + string(byte(i)+'a') // å°†å­èŠ‚ç‚¹çš„å€¼åŠ å…¥åˆ°å‰ç¼€ä¸²ä¸­
			if node.isLast {                           // å¦‚æœå­èŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªå•è¯ï¼Œåˆ™å°†å…¶åŠ å…¥åˆ°ç»“æœä¸­
				resMap[nextPrefix] = 1
			}
			board[row][col] = '$'
			if row > 0 && board[row-1][col] != '$' {
				dfs(node, board, row-1, col, nextPrefix, resMap)
			}
			if col < len(board[0])-1 && board[row][col+1] != '$' {
				dfs(node, board, row, col+1, nextPrefix, resMap)
			}
			if row < len(board)-1 && board[row+1][col] != '$' {
				dfs(node, board, row+1, col, nextPrefix, resMap)
			}
			if col > 0 && board[row][col-1] != '$' {
				dfs(node, board, row, col-1, nextPrefix, resMap)
			}
			board[row][col] = byte(i) + 'a'
		}
	}
}

type Trie struct {
	children []*Trie
	isLast   bool // æ˜¯å¦æŸä¸ªå•è¯ä»¥å½“å‰èŠ‚ç‚¹ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹ã€‚isLast == true ä¸ä»£è¡¨å½“å‰èŠ‚ç‚¹æ˜¯å¶èŠ‚ç‚¹
}

func NewTrie() *Trie {
	return &Trie{
		children: make([]*Trie, 26),
	}
}

func (this *Trie) Insert(word string) {
	cur := this
	for i := 0; i < len(word); i++ {
		char := word[i]
		if cur.children[char-'a'] == nil {
			cur.children[char-'a'] = NewTrie()
		}
		cur = cur.children[char-'a']
	}
	cur.isLast = true
}
```

## ä¼˜åŒ–è§£æ³•äºŒ
è§£æ³•äºŒå·²ç»åŒ…å«çš„ä¼˜åŒ–ï¼š`board[i][j]=='$'` è¡¨ç¤º `board[i][j] ` å·²ç»è¢«æœç´¢ï¼Œè¿™æ ·ä¸éœ€è¦ä¸€ä¸ª `visit[m][n]` æ•°ç»„ã€‚

è§£æ³•äºŒçš„æœç´¢è¿‡ç¨‹ä¸­ï¼Œéœ€è¦ä½¿ç”¨ä¸€ä¸ª `HashMap` å»æ‰é‡å¤æŸ¥æ‰¾åˆ°çš„å•è¯ã€‚å¯ä»¥åœ¨æ¯æ¬¡æ‰¾åˆ°æŸä¸ªå•è¯åï¼Œä»¤ `node.isLast = false`ï¼Œè¿™ç›¸å½“äºä»å‰ç¼€æ ‘ä¸­åˆ é™¤è¯¥å•è¯ï¼Œå°±ä¸éœ€è¦é¢å¤–çš„ `HashMap` äº†ã€‚
```diff
if node.isLast { // å¦‚æœå­èŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªå•è¯ï¼Œåˆ™å°†å…¶åŠ å…¥åˆ°ç»“æœä¸­
-    resMap[nextPrefix] = 1
+    res = append(res, nextPrefix)
+    node.isLast = false
}
```

æ­¤å¤–ï¼Œè§£æ³•äºŒä½¿ç”¨çš„å‰ç¼€æ ‘æ¯ä¸ªèŠ‚ç‚¹å¹¶ä¸ä¿å­˜å•è¯ï¼Œè€Œæ˜¯é€šè¿‡æ ¹èŠ‚ç‚¹åˆ°è¯¥èŠ‚ç‚¹çš„è·¯å¾„æ¥è¡¨ç¤ºä¸€ä¸ªå•è¯ã€‚å› æ­¤æœç´¢è¿‡ç¨‹ä¸­éœ€è¦ç»´æŠ¤ä¸€ä¸ªå­—ç¬¦ä¸² `prefix`ï¼Œè¡¨ç¤ºå½“å‰æœç´¢çš„å‰ç¼€ã€‚

å…¶å®å¯ä»¥ç›´æ¥å°†å®Œæ•´å•è¯ä¿å­˜åœ¨å‰ç¼€æ ‘çš„ `node` é‡Œï¼Œå°±ä¸éœ€è¦ `prefix` äº†ï¼Œèƒ½å¤Ÿé¿å…é¢‘ç¹åœ°æ„å»ºå­—ç¬¦ä¸²ï¼Œåœ¨å­—å…¸é‡ŒåŒ…å«ç‰¹åˆ«é•¿çš„å•è¯çš„æ—¶å€™å¯ä»¥æå‡è¿è¡Œé€Ÿåº¦ã€‚

ä¼˜åŒ–åçš„ä»£ç ï¼š
```go
var res []string

func findWords(board [][]byte, words []string) []string {
	if len(words) == 0 || len(board) == 0 {
		return nil
	}
	res = nil
	trie := NewTrie()
	for _, w := range words {
		trie.Insert(w)
	}
	for i := 0; i < len(board); i++ { // ä»æ¯ä¸ªä½ç½®å¼€å§‹æ‰¾
		for j := 0; j < len(board[0]); j++ {
			dfs(trie, board, i, j)
		}
	}
	return res
}

// åœ¨ä»¥ root ä¸ºæ ¹èŠ‚ç‚¹çš„å‰ç¼€æ ‘ä¸­ï¼Œæœç´¢ board æ˜¯å¦æœ‰åŒ¹é…çš„å‰ç¼€
// root æœ¬èº«ä¸åŒ…å«å­—ç¬¦ï¼Œå…¶å­èŠ‚ç‚¹æ‰åŒ…å«å­—ç¬¦
// rowã€col è¡¨ç¤ºå½“å‰æœç´¢çš„èµ·å§‹ä½ç½®ï¼Œboard[i][j]=='$' è¡¨ç¤º board[i][j] å·²ç»è¢«æœç´¢
func dfs(root *Trie, board [][]byte, row, col int) {
	for i, node := range root.children {
		if node != nil && board[row][col] == byte(i)+'a' { // å¦‚æœæŸä¸ªå­èŠ‚ç‚¹å’Œ board èµ·å§‹ç‚¹åŒ¹é…
			if node.word != "" { // å¦‚æœå­èŠ‚ç‚¹è¡¨ç¤ºä¸€ä¸ªå•è¯ï¼Œåˆ™å°†å…¶åŠ å…¥åˆ°ç»“æœä¸­
				res = append(res, node.word)
				node.word = ""
			}
			board[row][col] = '$'
			if row > 0 && board[row-1][col] != '$' {
				dfs(node, board, row-1, col)
			}
			if col < len(board[0])-1 && board[row][col+1] != '$' {
				dfs(node, board, row, col+1)
			}
			if row < len(board)-1 && board[row+1][col] != '$' {
				dfs(node, board, row+1, col)
			}
			if col > 0 && board[row][col-1] != '$' {
				dfs(node, board, row, col-1)
			}
			board[row][col] = byte(i) + 'a'
		}
	}
}

type Trie struct {
	children []*Trie
	word     string // å¦‚æœå½“å‰èŠ‚ç‚¹ä¸ºæœ€åä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¿å­˜å…¶è¡¨ç¤ºçš„å•è¯
}

func NewTrie() *Trie {
	return &Trie{
		children: make([]*Trie, 26),
	}
}

func (this *Trie) Insert(word string) {
	cur := this
	for i := 0; i < len(word); i++ {
		char := word[i]
		if cur.children[char-'a'] == nil {
			cur.children[char-'a'] = NewTrie()
		}
		cur = cur.children[char-'a']
	}
	cur.word = word
}
```

## ç»“è¯­
æœ¬æ–‡å‘è¡¨åœ¨æˆ‘çš„åšå®¢ [https://imageslr.github.io/](https://imageslr.github.io/)ã€‚æˆ‘ä¹Ÿä¼šåˆ†äº«æ›´å¤šçš„é¢˜è§£ï¼Œä¸€èµ·äº¤æµï¼Œå…±åŒè¿›æ­¥ï¼