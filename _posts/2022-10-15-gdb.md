---
layout: post
title: 💻【Linux】GDB 学习笔记 🆕
date: 2022/10/13 18:00
typora-root-url: ../
typora-copy-images-to: ../media/gdb
---

- [ ] 搜索 todo，替换超链接

## 前言

[GDB](https://sourceware.org/gdb/) 全称 GNU Project debugger，是一个通用的 C / C++ 程序调试器，可以用来深入分析程序的运行过程，或者排查程序崩溃的原因。

GDB 主要有以下几个功能：

1. 运行程序，随心所欲地查看程序内部状态 (如变量值、寄存器值)、控制程序的行为 (如逐行执行、反向执行等)
2. 使程序在特定位置中断，也可以按条件中断
3. 当程序崩溃时，查看完整现场，分析发生了什么
4. 改变程序状态 (如临时修改某个变量值)，以测试程序在不同情况下的行为

在日常工作中，我经常会使用 GDB。比如线上发生 coredump #TODO，需要用 GDB 来排查。又或者调试程序 bug，靠 `printf` 排查效率很低，学习了 GDB 以后，效率直线上升。

>  TODO 这里说明一下为什么不用 IDE、为什么非得用 GDB

一般来说，我们学会 `bt` (查看堆栈)、`p` (打印变量)、`b` (设置断点) 等几个基本命令，就可以使用 GDB 了。但 GDB 就像一把瑞士军刀，功能丰富，只有深入掌握，才能成为效率提升利器。

本文面向的读者是 C / C++ 程序员，主要内容包括 GDB 的基本命令、进阶用法、排查案例和使用技巧。目标是使读者掌握 GDB 的应用场景和使用方法，满足日常开发所需；同时，读者可以将本文作为 GDB 命令的速查手册，随时查阅。

<div class="ant-alert" markdown="1">
**本文约定：**
{: .mb-1}
* 代码格式：如果没有前缀，或者前缀是 `$`，表示在 shell 执行；如果前缀是 `(gdb)`，表示在 GDB 内执行；`(gdb)` 命令后面的 `// xxx` 是注释内容，不包含在要执行的命令中。
{: .mb-1}
* 环境要求：gcc / g++，gdb。推荐[使用 docker 初始化]()TODO。
</div>




## 〇、Hello, world

### 安装 GDB

本文在 Linux (CentOS) 环境下运行 GDB，读者也可以使用[网页版 GDB](https://www.onlinegdb.com)。

Linux 系统可以使用包管理器安装：

```
$ sudo apt-get update
$ sudo apt-get install gdb
```

Mac 系统可以使用 brew 安装：

```
$ brew install gdb
```

Mac 还需要给 GDB 签名，参考 [GDB Wiki](https://sourceware.org/gdb/wiki/PermissionsDarwin)，否则会有这样的报错：

```
Starting program: /x/y/foo
Unable to find Mach task port for process-id 28885: (os/kern) failure (0x5).
 (please check gdb is codesigned - see taskgated(8))
```

### 使用 GDB

下面是一个使用 GDB 断点调试的示例。

1. 编写 C++ 程序：

   ```c++
   // main.cpp
   #include <iostream>
   using namespace std;
   
   void print_foo(int v) {
     int i = v + 5;
     i = i + 3;
     cout << "i == " << i << endl;
   }
   
   int main() {
     int a = 0;
     a += 1;
     a += 2;
     print_foo(a);
     return 0;
   }
   ```

2. 编译程序，添加 `-g` 选项，保留 debug info #TODO:

   ```plaintext
   $ g++ -g main.cpp -o example
   ```

3. 进入 gdb，加载二进制程序，最后一行表示符号表加载成功：

   ```
   $ gdb example
   GNU gdb (GDB) 12.1
   Copyright ...
   Find the GDB manual and other documentation resources online at:
       <http://www.gnu.org/software/gdb/documentation/>.
   For help, type "help".
   Type "apropos word" to search for commands related to "word"...
   Reading symbols from example...
   ```

4. 在 `main()` 函数第一行设置一个断点，运行程序：

   ```
   (gdb) b main.cpp:12
   Breakpoint 1 at 0x55555555522c: file main.cpp, line 12.
   (gdb) r
   Starting program: /home/a.out 
   Breakpoint 1, main () at main.cpp:12
   12        int a = 0;
   ```

5. 逐行执行程序，打印变量 `a` 的值：

   ```
   (gdb) next
   13        a += 1;
   (gdb) p a
   $3 = 1
   (gdb) next
   14        a += 2;
   (gdb) next
   15        print_foo(a);
   (gdb) p a
   $4 = 3
   ```

   `next` 命令输出的是下一行要执行的代码。如果下一行是函数，`next` 命令会执行完整个函数，跳过函数的下一行，这是 step over。

6. `step` 命令会进入函数，停在函数的第一行，这是 step into：

   ```
   (gdb) step    
   print_foo (v=21845) at main.cpp:5
   5       void print_foo(int v) {
   ```

7. `backtrack` 命令可以查看当前程序的调用栈：

   ```
   (gdb) backtrace
   #0  print_foo (v=21845) at main.cpp:5
   #1  0x0000555555555245 in main () at main.cpp:15
   ```

8. `continue` 命令会执行程序，直到遇到下一个断点。这里没有下一个断点了，整个程序正常退出：

   ```
   (gdb) continue
   Continuing.
   [Inferior 1 (process 1308) exited normally]
   ```

### 命令的形式

大部分 GDB 命令都有一个简写形式，一般是命令的首字母，比如：

* `backtrace` → `bt`
* `break` → `b`
* `continue` → `c`
* `next` → `n`
* `info` → `i`

此外，在 GDB 中如果什么都不输入，直接回车，会重复执行上一条命令。

### 静态和动态

GDB 可以是“静态”的，也可以是“动态”的。

当应用程序异常退出时，操作系统会生成一个 coredump #TODO 文件，记录了程序退出时的所有内存状态。GDB 可以读取这个文件，查看程序退出时的变量值或者寄存器值，但是无法执行程序。这是“静态”的。

GDB 也可以直接加载一个二进制程序并执行。在这种情况下，GDB 不仅可以随时查看程序当前的变量值或其他内存状态，还可以控制程序的运行，如设置断点、单步执行、反向执行等。这是“动态”的。

大部分命令都可以在这两种模式下使用，而某些命令如 `run`、`break`、`continue` 只能在“动态”模式下使用。

### 文档和术语

在 GDB 内执行 `help {command}` 可以查看每个命令的帮助文档。

此外，使用 GDB 需要了解一些计算机系统的背景知识：

* 基础：coredump、栈帧、线程等。
* 进阶：寄存器、汇编、ABI 等。

这些术语说明详见附录。

## 基本命令

### 选择线程: `t`

`info thread` 可以查看当前进程的所有线程。示例程序是单线程的：

```
(gdb) info threads
  Id   Target Id            Frame 
* 1    process 1537 "example" main () at main.cpp:15
```

`thread` / `t` 可以查看当前位于哪个线程：

```
(gdb) t
[Current thread is 1 (process 3496)]
```

在多线程程序里，可以通过 `t {id}` 切换线程，每个线程有独立的调用栈。

### 查看堆栈: `bt`

`backtrace` / `bt` 可以查看调用栈。调用栈展示了从 `main()` 入口到当前断点或进程退出时刻的所有函数调用路径：

```
(gdb) bt
#0  0x0 in (unknown) at :0
#1  0x1a796e7c in foo() at main.cpp:13
#2  0x6259058 in bar() at main.cpp:17
#3  0x6bb7580 in main() at main.cpp:83
```

### 选择栈帧: `f`

每次函数调用，会创建一个独立的栈帧 #TODO，对应上面的 `#0`、`#1`、`#2`。默认在最底层 `#0`。

`frame` / `f ` 可以跳转到指定栈帧：

```
(gdb) f 2
#2  bar() at main.cpp:17
17        int a = foo();
```

`up` / `down` 可以向上层或下层跳转，对应编号增大或减小。

### 打印变量: `p`

#### 基本使用

`print` / `p` 可以打印一个变量的值，支持数字、字符串、结构体、指针等变量类型：

```
(gdb) p a // int a = 3;
$1 = 3
```

打印出来的值会存在名为 `$1`、`$2`、... 的变量里，后续可以直接复用：

```
(gdb) p $1 // 等价于 p a
$2 = 3
```

`p` 可以打印当前栈帧和全局作用域内的变量。如果打印变量时提示变量已经 `optimized`，可以尝试用 `f` 切换到更上层的栈帧。

`p` 有一些可选参数：

* `-elements`：限制字符串或者数组打印的元素数量
* `-max-depth`：限制嵌套结构体的最大打印层数
* ...，`help p` 查看所有参数

#### 打印指针

`p` 后面跟一个指针，打印的是指针的值，即指针所指向的地址：

```
(gdb) p b // int* b = &a;
$1 = (int *) 0x7ffd3dcfa27c
```

可以用解引用运算符，打印指针指向的值：

```
(gdb) p *b
$3 = 1
```

对于字符串指针，`p` 会顺便输出字符串的内容：

```
p str
$27 = (char*) 0x7ffc734ff250 "hello,world"
```

如果希望只打印地址，可以使用说明符 `/a`：

```
(gdb) p/a str
$28 = 0x7ffc734ff250
```

>   `/a` 表示 `address`，即把变量的值以地址的形式打印。

---

`p` 会把十六进制的地址看成是数字，输出一个十进制的整数：

```
(gdb) p 0x7ffd3dcfa27c
$1 = 140725640471164
(gdb) p 140725640471164 == 0x7ffd3dcfa27c
$26 = true
```

如果希望将数字解释为地址、打印该地址上的内容，需要先指定其指针类型，再解引用：

```
(gdb) p *(int*)0x7ffd3dcfa27c
$6 = 1
```

更简单的语法是 `{TYPE}ADDRESS：`

```
(gdb) p {int}0x7ffd3dcfa27c
$4 = 1
```

也可以用 `x` 命令打印地址。TODO 如何指定类型？

---

指针的类型可以转换，以不同方式解释其指向的内存区域：

```
// char* c = "hello, world";
(gdb) p c
$1 = (char *) 0x7ffc734ff250 "hello, world";
(gdb) p *(int*)c
$2 = 1819043176
(gdb) p {int}c
$3 = 1819043176
```

打印内存可以发现，1819043176 就是把 `h e l l` 四个字符的 ASCII 码解释成了一个整数：

```
(gdb) x/c 0x7ffc734ff250
0x7ffc734ff250:	'h'
(gdb) x/d 0x7ffc734ff250
0x7ffc734ff250:	104
(gdb) x/w 0x7ffc734ff250
0x7ffc734ff250:	1819043176
```

#### 打印数组

{% raw %}

`p ELEMENT@LEN`：
* `@` 左侧是数组的第一个元素，右侧是要打印的元素个数。
* GDB 会取 `ELEMENT` 的地址 A 和类型 T，从地址 A 开始向后解释一块连续的内存，内存大小为 `sizeof(T)*LEN` 字节。

如果 array 是**栈上数组**，可以直接 `p array`：

```plaintext
// int array[] = {1, 2, 3, 4};
(gdb) p array
$7 = {1, 2, 3, 4}
```

或者 `p array[INDEX]@LEN`，从某个下标开始打印：

```
(gdb) p array[1]@[3] // array[1] 的类型是 int
$7 = {1, 2, 3}
```

但不能 `p array@LEN`：

```
(gdb) p array@3 // 栈上数组，array 的类型是 int[4]，导致多解释了内存
$8 = {{1, 2, 3, 4}, {-693741568, 32764, 1033857024, -1536906435}, {0, 0, -793505661, 32580}}
```

如果 array 是**堆上数组**，可以 `p *array@LEN`：

```
// int* array = (int*)malloc(3 * sizeof(int));
(gdb) p *array@3 // *array 是数组的第一个元素，类型是 int
$9 = {1, 2, 3}
```

或者 `p array[INDEX]@LEN`，从某个下标开始打印：

```
(gdb) p array[1]@3 // array[1] 的类型是 int
$10 = {2, 3, 4}
```

但不能 `p array` 或者 `p array@LEN`：

```
(gdb) p array // array 是一个指针，类型 int*，值是一个地址
$11 = 0x55669a743eb0
(gdb) p array@3 // array 是一个指针，类型 int*，这里会输出 3 个地址，后两个是 array 这个变量的相邻内存的值，没有任何意义
$12 = {0x55669a743eb0, 0x55669a255330, 0x200000001}
```

{% endraw  %}

#### 格式化输出

可以在 `p` 后面添加说明符 (specifier)，将一个变量解释为给定的类型：

```
(gdb) p foo // int foo = 98;
$1 = 98
(gdb) p/c foo // 将 98 解释为字符
$2 = 98 'b'
```

所有说明符：

* `p/a`：将变量解释为指针 address，使用十六进制打印

* `p/c`：将变量解释为字符 char，打印为字符

* `p/o`：使用八进制打印变量

* `p/x`：使用十六进制打印变量

* `p/u`：将变量解释为无符号整数 unsigned，使用十进制打印

* `p/s`：将变量解释为字符串，打印输出

* `help x` 查看全部：

  ```
  b(byte), h(halfword), w(word), g(giant, 8 bytes)
  o(octal), x(hex), d(decimal), u(unsigned decimal),
  t(binary), f(float), a(address), i(instruction), 
  c(char), s(string) and z(hex, zero padded on the left)
  ```

打印内存值的 `x` 命令也有同样的说明符，见下文打印内存 #TODO。

p 和 x 的区别：TODO

* 传给 p 一个 0x6f772c6f6c6c6568，p 把它当做一个数字，输出一个十进制整数
* x 看成是地址
* `p/u pointer` 和 `x/u pointer` 不一样，前者把 pointer 的地址看成一个数字，后者把 pointer 指向的地址上面的内容看成一个数字。`p 0x1231241` 和 `x 0x1231241` 的区别。TODO 测试下
* 传给 p 一个指针

#### STL 容器

##### std::shared_ptr

直接打印：

```
// std::shared_ptr<int> ptr = std::make_shared<int>(1);
(gdb) p ptr
$1 = std::shared_ptr<int> (use count 1, weak count 0) = {
  get() = 0x5596169122f0}
(gdb) p *ptr
$2 = 1
```

或者根据上面 `get()` 方法给出的地址打印：

```
(gdb) p {int}0x5596169122f0
$3 = 1
```

或者根据 shard_ptr 内部的私有变量 `_M_ptr` 打印：

```
(gdb) p ptr._M_ptr
$4 = 0x5596169122f0
(gdb) p *(ptr._M_ptr)
$5 = 1
```

##### std::vector

直接打印：

```
// std::vector<int> vec = {1, 2, 3, 4};
(gdb) p vec
$1 = std::vector of length 4, capacity 4 = {1, 2, 3, 4}
```

vector 也有私有变量保存了数据的实际存储位置：

* `_M_impl._M_start`：数组起始地址
* `_M_impl._M_finish`：数组结束地址 (数组最后一个元素的下一个)

可以直接根据这个指针打印：

```
(gdb) p vec._M_impl._M_start
$2 = 0x5563f18c6300
(gdb) p {int}vec._M_impl._M_start
$3 = 1
(gdb) p {int}vec._M_impl._M_start@3
$4 = {1, 2, 3}
```

##### std::string

直接打印：

```
(gdb) p str
$1 = "hello,world"
```

或者根据私有变量 `_M_dataplus._M_p` 打印，其类型是 `char*`：

```
(gdb) p str._M_dataplus._M_p
$35 = (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::pointer) 0x7ffc734ff250 "hello,world"

(gdb) x/s str._M_dataplus._M_p
0x7ffc734ff250:	"hello,world"
```

### 打印内存: `x`

传给 x 的是一个地址



### 打印字符串: `TODO`

x/s

set print elements 0 打印所有长度的字符串

打印字符串，不要 repeated

### 打印类型: `ptype`

```
(gdb) ptype foo
type = int
```



### 存储变量: `set`

打印的变量会默认存成数字名的变量：



也可以不打印，直接保存一个变量



### 断点调试: `b`

#### 基本使用

设置断点

删除断点

#### 条件断点



#### 断点语法

help b



#### 逐步执行: `s`、`n`



### 监控变量: `watch`



### 输出日志: `set logging`

打印日志挪到这里

## 进阶用法



### 加载插件: `source`

上面打印 STL 就是一个加载插件的案例



### 反向调试: `reverse`



### 可视化界面



### 在 VS Code 中使用



## 排查案例 



## 最佳实践

> 技巧、Tips 等

💡 如果栈顶打印变量 optimized 了，可以 `f` 去更顶层的栈帧 (编号更大的) 打印。





## 附录

### 学习资源

> 分类：文档、技巧、案例

GDB 官网：https://sourceware.org/gdb/

100 个 GDB 小技巧



### 常见问题

#### 已经有 CLion、VS Studio 这些 IDE 了，还需要学习 GDB 吗？

不同的应用场景

比如我们公司 大部分项目很大，不能本地开发

远程只能用 VS Code

VS Code 可以配置可视化调试，但是运行速度慢，效率低

GDB 适用场景很广

核心思路：使用不同的独立的工具构建你的工作流，而不是使用一个大而全的工具。前者能够适应更多的场景。

在实际的生产环境下，服务程序都运行在 k8s 容器中，都是 Linux 系统，只能使用 GDB。



### 术语说明



#### 调用栈 / 栈帧

调用栈 call stack

栈帧  stack frame

每一次函数的调用,都会在调用栈(call stack)上维护一个独立的栈帧(stack frame)

每个独立的栈帧一般包括:

- 函数的返回地址和参数
- 临时变量: 包括函数的非静态局部变量以及编译器自动生成的其他临时变量
- 函数调用的上下文 

栈从高地址向低地址延伸

#### core dump

什么时候会 core

core dump 文件的格式



核心转储是一个二进制文件，只能由调试器读取。GDB就是这样一个调试器，也是最好的调试器之一。核心转储可以由崩溃的应用程序本身写入（虽然不常用，但这是可能的，而且一些较大的服务器级软件可能会使用它），但更常见的是由操作系统本身写入。
一些操作系统默认禁用了核心转储，或者将核心转储最小化为迷你转储，这可能有助于调试应用程序，但可能比完整核心转储更受限制。此外，完整的核心转储可能会有问题；例如，如果您的系统有128GB内存，而您的应用程序正在使用大部分内存，那么核心转储（磁盘上的文件）的大小可能大致相等。
在您的特定操作系统上配置核心转储超出了本文的范围，但此信息在网上相对容易找到。只需在您最喜欢的搜索引擎中搜索类似“Configure core dumps on Linux Mint”的短语，将“Mint”替换为您的Linux操作系统名称。

#### debug info

调试用的符号表，保留标识符名称

没有的话只能 r

```
No symbol table is loaded.  Use the "file" command.
```

-g 是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，

这个要求本地存在源代码，gdb 会读取源代码内容并展示

如果没有 debug info，`l` 就没法展示代码

#### 动态链接库 / LD_LIBRARY_PATH



### 相关文章

📒  相关文章：💻【Linux】Vim 学习笔记 #TODO
{: .ant-alert .ant-alert-info}

