---
layout: post
title: ğŸ“ã€LeetCodeã€‘78ã€90 å…¨ç»„åˆï¼ˆå­é›†ï¼‰
date: 2020/1/29 21:00
---

## å…¨ç»„åˆ
### é—®é¢˜æè¿°
è¿™é“é¢˜æ˜¯ [LeetCode 78 é¢˜ - å­é›†](https://leetcode-cn.com/problems/subsets/)ã€‚

ä»**ä¸å«é‡å¤å…ƒç´ **çš„ n ä¸ªå…ƒç´ ä¸­ï¼Œé€‰æ‹© 0~n ä¸ªå…ƒç´ ï¼Œç»„æˆä¸€ä¸ªå­é›†ï¼Œæ‰¾å‡ºæ‰€æœ‰çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

### è§£æ³•ä¸€ï¼šäºŒè¿›åˆ¶è½¬æ¢æ³•
å¦‚æœ n ä¸ªå…ƒç´ éƒ½ä¸ç›¸åŒï¼Œå¯ä»¥ä½¿ç”¨äºŒè¿›åˆ¶è½¬æ¢æ³•æ±‚å¾—æ‰€æœ‰çš„å­é›†ã€‚å°†ä¸€ä¸ªæ•°ä» 0 å¼€å§‹ï¼Œæ¯æ¬¡åŠ  1ï¼Œä¸€ç›´åŠ åˆ° $2^n-1$ï¼Œå…¶äºŒè¿›åˆ¶è¡¨ç¤ºä» `000...000` åˆ° `111...111`ï¼Œæ¯ä¸€ä½è¡¨ç¤ºå¯¹åº”å…ƒç´ æ˜¯å¦è¢«é€‰æ‹©ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(nÃ—2^n)$ã€‚  
ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œéœ€è¦ä¸€ä¸ªæ•°ç»„ä¸´æ—¶ä¿å­˜æ¯ä¸ªç»„åˆï¼Œä¸ç®—ä¿å­˜æœ€ç»ˆç»“æœæ‰€éœ€çš„ç©ºé—´ã€‚

```go
func subsets(nums []int) [][]int {
	if len(nums) == 0 {
		return nil
	}
    res := [][]int{}
	sum := 1 << uint(len(nums))
	for i := 0; i < sum; i++ {
		stack := []int{}
		tmp := i
		for j := len(nums) - 1; j >= 0; j-- {
			if tmp & 1 == 1 {
				stack = append([]int{nums[j]}, stack...)
			}
			tmp >>= 1
		}
		res = append(res, stack)
	}
	return res
}
```

### è§£æ³•äºŒï¼šé€’å½’ï¼ˆå›æº¯ç®—æ³•ï¼‰
ä¾æ¬¡ä» `[start,n]` é€‰æ‹©ä¸€ä¸ªå…ƒç´  `i`ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„ç»„åˆã€‚ç„¶åè¿›å…¥ä¸‹ä¸€å±‚ï¼Œä¸‹ä¸€å±‚åªèƒ½é€‰æ‹© `[i+1,n]` ä¹‹é—´çš„å…ƒç´ ã€‚ä»ä¸‹ä¸€å±‚è¿”å›æ—¶ï¼Œåˆ é™¤åˆšæ‰é€‰çš„è¿™ä¸ªå…ƒç´ ï¼Œç»§ç»­é€‰æ‹©ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚è¿™æ˜¯ä¸€ä¸ªå›æº¯çš„è¿‡ç¨‹ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(2^n)$ã€‚æ¯æ¬¡é€’å½’éƒ½ä¼šæ‰¾åˆ°ä¸€ä¸ªè§£ï¼Œä¸€å…± $2^n$ ä¸ªè§£ã€‚  
ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œé€’å½’çš„æœ€å¤§æ·±åº¦ï¼Œä¸ç®—ä¿å­˜æœ€ç»ˆç»“æœæ‰€éœ€çš„ç©ºé—´ã€‚

ä»£ç ï¼š
```go
var res [][]int
var stack []int

func subsets(nums []int) [][]int {
	res = [][]int{}
	stack = []int{}
	if len(nums) == 0 {
		return nil
	}
	dfs(nums, 0)
	return res
}

func dfs(nums []int, start int) {
	tmp := make([]int, len(stack))
	copy(tmp, stack)
	res = append(res, tmp)
	for i := start; i < len(nums); i++ { // ä» start å¼€å§‹éå†
		stack = append(stack, nums[i])
		dfs(nums, i+1) // åªå…è®¸åœ¨ä¹‹åçš„å…ƒç´ é‡Œéå†
		stack = stack[:len(stack)-1] // å›æº¯
	}
}
```

### è§£æ³•ä¸‰ï¼šé€ä¸ªæšä¸¾æ³•
å°†ç©ºé›†ä½œä¸ºé»˜è®¤å­é›†ï¼Œç„¶åé€ä¸ªæšä¸¾é›†åˆä¸­çš„å…ƒç´ ã€‚æ¯æ–°å¢ä¸€ä¸ªå…ƒç´ ï¼Œå°±åœ¨ä¹‹å‰çš„æ‰€æœ‰å­é›†ä¸­è¿½åŠ è¿™ä¸ªå…ƒç´ ï¼Œå¾—åˆ°æ–°å¢çš„å­é›†ã€‚

æ¯æ–°å¢ä¸€ä¸ªå…ƒç´ ï¼Œå­é›†ä¸ªæ•°ç¿»å€ï¼Œå› æ­¤ n ä¸ªå…ƒç´ çš„æ‰€æœ‰å­é›†ä¸ªæ•°ä¸º $2^n$ã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$O(2^n)$ã€‚æ¯æ¬¡éå†çš„å­é›†ä¸ªæ•°ä¾æ¬¡ä¸º $1,2,4,...,2^n$ï¼Œå¥—ç”¨ç­‰æ¯”æ•°åˆ—æ±‚å’Œå…¬å¼ï¼Œéå†æ€»æ¬¡æ•°ä¸º $O(2^n)$ã€‚  
ç©ºé—´å¤æ‚åº¦ï¼š$O(n^2Ã—2^n)$ã€‚å¯ä»¥è¿™æ ·æ¨å¯¼ï¼šæ¯æ–°å¢ä¸€ä¸ªå…ƒç´ ï¼Œå­é›†ä¸ªæ•°ç¿»å€ï¼Œæ–°å¢çš„å­é›†é•¿åº¦ä¹Ÿç¿»å€ï¼Œåˆ™ n å±‚æ€»çš„å­é›†é•¿åº¦ä¸º $\sum_{i=1}^n{(2^{i-1}Ã—{i-1}+2^{i-1}Ã—i)}$ã€‚æ‹¬å·å†…åˆä¸ºä¸€é¡¹ $O(iÃ—2^i)$ï¼Œæ€»çš„æ—¶é—´å¤æ‚åº¦å¯è¡¨ç¤ºä¸º $O(n^2Ã—2^n)$ã€‚

ä»£ç ï¼š
```go
func subsets(nums []int) [][]int {
	if len(nums) == 0 {
		return nil
	}
    res := [][]int{[]int{}}
    for _, v := range nums {
        size := len(res)
        for i := 0; i < size; i++ {
            newSub := make([]int, len(res[i]))
            copy(newSub, res[i])
            newSub = append(newSub, v)
            res = append(res, newSub)
        }
    }
	return res
}
```

## å…¨ç»„åˆï¼ˆåŒ…å«é‡å¤å…ƒç´ ï¼‰
### é—®é¢˜æè¿°
è¿™é“é¢˜æ˜¯ [LeetCode 90é¢˜ - å­é›†-ii](https://leetcode-cn.com/problems/subsets-ii/)ã€‚

ä»**å¯èƒ½åŒ…å«é‡å¤å…ƒç´ **çš„ n ä¸ªå…ƒç´ ä¸­ï¼Œé€‰æ‹© 0~n ä¸ªå…ƒç´ ï¼Œç»„æˆä¸€ä¸ªå­é›†ï¼Œæ‰¾å‡ºæ‰€æœ‰çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚

è¯´æ˜ï¼š**è§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„å­é›†**ã€‚

### è§£æ³•ä¸€ï¼šäºŒè¿›åˆ¶è½¬æ¢æ³•
å°†åŸæ¥çš„è§£æ³•è°ƒæ•´ä¸ºï¼šå…ˆå°†åŸæ•°ç»„æ’åºï¼Œç„¶å**ç›¸é‚»çš„ç›¸åŒå…ƒç´ ï¼Œå¿…é¡»è¿ç»­é€‰æ‹©**ã€‚

ä»£ç ï¼š
```go
func subsetsWithDup(nums []int) [][]int {
	if len(nums) == 0 {
		return nil
	}
	sort.Ints(nums) // å…ˆæ’åº
	res := [][]int{}
	sum := 1 << uint(len(nums))
	for i := 0; i < sum; i++ {
		stack := []int{}
		tmp := i
+		valid := true
		for j := len(nums) - 1; j >= 0; j-- {
			if tmp&1 == 1 {
+				if j > 0 && nums[j] == nums[j-1] && (tmp>>1)&1 == 0 {
+					valid = false
+					break
+				}
				stack = append([]int{nums[j]}, stack...)
			}
			tmp >>= 1
		}
+		if valid {
			res = append(res, stack)
+		}
	}
	return res
}
```
> ä»£ç ä¸­çš„â€œ+â€å·è¡¨ç¤ºè¿™æ˜¯ç›¸æ¯”äº 78 é¢˜çš„ä»£ç æ–°å¢çš„è¡Œ

### è§£æ³•äºŒï¼šé€’å½’ï¼ˆå›æº¯ç®—æ³•ï¼‰
å’Œ[å…¨æ’åˆ—ï¼ˆåŒ…å«é‡å¤å…ƒç´ ï¼‰]({% post_url 2020-01-27-leetcode-36 %}#å…¨æ’åˆ—åŒ…å«é‡å¤å…ƒç´ )çš„æ€è·¯ç›¸åŒï¼Œåªéœ€**åœ¨æ¯è½®é€’å½’æ—¶ä¸é‡å¤é€‰æ‹©ç›¸åŒçš„å…ƒç´ **å³å¯ã€‚**ä¸€ç§æ–¹æ³•æ˜¯å°†åŸæ•°ç»„æ’åºï¼Œæ¯å±‚é€’å½’ä¸­ï¼Œç›¸é‚»çš„ç›¸åŒå…ƒç´ ï¼Œåªé€‰æ‹©ç¬¬ä¸€ä¸ªï¼ˆä¸èƒ½åªé€‰æ‹©æœ€åä¸€ä¸ªï¼‰ï¼›å¦ä¸€ç§æ–¹æ³•æ˜¯ä½¿ç”¨ä¸€ä¸ªå“ˆå¸Œè¡¨è®°å½•æœ¬è½®é€’å½’è¿‡ç¨‹ä¸­å·²ç»é€‰æ‹©è¿‡çš„å…ƒç´ ï¼Œä¸å†é‡å¤é€‰æ‹©ã€‚**
> ä¸ºä»€ä¹ˆâ€œç›¸é‚»çš„ç›¸åŒå…ƒç´ ï¼Œåªé€‰æ‹©ç¬¬ä¸€ä¸ªï¼Œä¸èƒ½åªé€‰æ‹©æœ€åä¸€ä¸ªâ€ï¼Ÿ  
> æ±‚[å…¨æ’åˆ—]({% post_url 2020-01-27-leetcode-36 %}#å…¨æ’åˆ—åŒ…å«é‡å¤å…ƒç´ )çš„æ—¶å€™ï¼Œæ¯å±‚é€’å½’éƒ½ä¼šä» `0` å¼€å§‹éå†æ‰€æœ‰çš„å…ƒç´ ï¼›è€Œæ±‚å…¨ç»„åˆçš„æ—¶å€™ï¼Œæ¯å±‚é€’å½’ä¼šä» `start` å¼€å§‹éå†æ‰€æœ‰çš„å…ƒç´ ã€‚å¦‚æœåè€…â€œç›¸é‚»çš„ç›¸åŒå…ƒç´ â€é€‰æ‹©æœ€åä¸€ä¸ªï¼Œè€Œä¸æ˜¯ç¬¬ä¸€ä¸ªï¼Œä¼šä¸¢å¤±éƒ¨åˆ†è§£ã€‚

ä»£ç ï¼š
```go
var res [][]int
var stack []int

func dfs(nums []int, start int) {
	tmp := make([]int, len(stack))
	copy(tmp, stack)
	res = append(res, tmp)
	for i := start; i < len(nums); i++ { // ä» start å¼€å§‹éå†
+		if i > start && nums[i] == nums[i-1] {
+			continue // ç›¸åŒçš„å€¼ï¼Œåªé€‰æ‹©ç¬¬ä¸€ä¸ªï¼Œä¸é‡å¤é€‰æ‹©
+		}
		stack = append(stack, nums[i])
		dfs(nums, i+1) // åªå…è®¸åœ¨ä¹‹åçš„å…ƒç´ é‡Œéå†
		stack = stack[:len(stack)-1]
	}
}

func subsetsWithDup(nums []int) [][]int {
	if len(nums) == 0 {
		return nil
	}
	res = [][]int{}
	stack = []int{}
+	sort.Ints(nums) // å…ˆæ’åº
	dfs(nums, 0)
	return res
}
```
> ä»£ç ä¸­çš„â€œ+â€å·è¡¨ç¤ºè¿™æ˜¯ç›¸æ¯”äº 78 é¢˜çš„ä»£ç æ–°å¢çš„è¡Œ

### è§£æ³•ä¸‰ï¼šé€ä¸ªæšä¸¾æ³•
å°†åŸæ¥çš„è§£æ³•è°ƒæ•´ä¸ºï¼šå…ˆå¯¹æ•°ç»„æ’åºï¼Œç„¶åæ¯æ–°å¢ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æœå’Œå‰ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œé‚£ä¹ˆ**åªåœ¨å‰ä¸€ä¸ªå…ƒç´ æ–°å¢çš„å­é›†ä¸­è¿½åŠ è¿™ä¸ªå…ƒç´ **ï¼Œå¾—åˆ°æ–°å¢çš„å­é›†ã€‚

ä»£ç ï¼š
```go
func subsetsWithDup(nums []int) [][]int {
	if len(nums) == 0 {
		return nil
	}
+	sort.Ints(nums) // å…ˆæ’åº
	res := [][]int{[]int{}}
	preSize := 0
	for idx, v := range nums {
		i, size := 0, len(res)
+		if idx > 0 && nums[idx] == nums[idx-1] {
+			i = preSize
+		}
		for ; i < size; i++ {
			newSub := make([]int, len(res[i]))
			copy(newSub, res[i])
			newSub = append(newSub, v)
			res = append(res, newSub)
		}
+		preSize = size
	}
	return res
}
```
> ä»£ç ä¸­çš„â€œ+â€å·è¡¨ç¤ºè¿™æ˜¯ç›¸æ¯”äº 78 é¢˜çš„ä»£ç æ–°å¢çš„è¡Œ

## ç»“è¯­
æœ¬æ–‡å‘è¡¨åœ¨æˆ‘çš„åšå®¢ [https://imageslr.github.io/](https://imageslr.github.io/)ã€‚æˆ‘ä¹Ÿä¼šåˆ†äº«æ›´å¤šçš„é¢˜è§£ï¼Œä¸€èµ·äº¤æµï¼Œå…±åŒè¿›æ­¥ï¼